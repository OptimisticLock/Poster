[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\n\n/* Package-scope variables */\nvar makeInstaller, meteorInstall;\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n// packages/modules-runtime/.npm/package/node_modules/install/install.js    //\n// This file is in bare mode and is not in its own closure.                 //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n                                                                            //\nmakeInstaller = function (options) {                                        // 1\n  options = options || {};                                                  // 2\n                                                                            // 3\n  // These file extensions will be appended to required module identifiers  // 4\n  // if they do not exactly match an installed module.                      // 5\n  var extensions = options.extensions || [\".js\", \".json\"];                  // 6\n                                                                            // 7\n  // This constructor will be used to instantiate the module objects        // 8\n  // passed to module factory functions (i.e. the third argument after      // 9\n  // require and exports).                                                  // 10\n  var Module = options.Module || function Module(id, parent) {              // 11\n    this.id = id;                                                           // 12\n    this.parent = parent;                                                   // 13\n  };                                                                        // 14\n                                                                            // 15\n  // If defined, the options.onInstall function will be called any time     // 16\n  // new modules are installed.                                             // 17\n  var onInstall = options.onInstall;                                        // 18\n                                                                            // 19\n  // If defined, the options.override function will be called before        // 20\n  // looking up any top-level package identifiers in node_modules           // 21\n  // directories. It can either return a string to provide an alternate     // 22\n  // package identifier, or a non-string value to prevent the lookup from   // 23\n  // proceeding.                                                            // 24\n  var override = options.override;                                          // 25\n                                                                            // 26\n  // If defined, the options.fallback function will be called when no       // 27\n  // installed module is found for a required module identifier. Often      // 28\n  // options.fallback will be implemented in terms of the native Node       // 29\n  // require function, which has the ability to load binary modules.        // 30\n  var fallback = options.fallback;                                          // 31\n                                                                            // 32\n  // Whenever a new require function is created in the makeRequire          // 33\n  // function below, any methods contained by options.requireMethods will   // 34\n  // be bound and attached as methods to that function object. This option  // 35\n  // is intended to support user-defined require.* extensions like          // 36\n  // require.ensure and require.promise.                                    // 37\n  var requireMethods = options.requireMethods;                              // 38\n                                                                            // 39\n  // Nothing special about MISSING.hasOwnProperty, except that it's fewer   // 40\n  // characters than Object.prototype.hasOwnProperty after minification.    // 41\n  var hasOwn = {}.hasOwnProperty;                                           // 42\n                                                                            // 43\n  // The file object representing the root directory of the installed       // 44\n  // module tree.                                                           // 45\n  var root = new File(\"/\", new File(\"/..\"));                                // 46\n  var rootRequire = makeRequire(root);                                      // 47\n                                                                            // 48\n  // Merges the given tree of directories and module factory functions      // 49\n  // into the tree of installed modules and returns a require function      // 50\n  // that behaves as if called from a module in the root directory.         // 51\n  function install(tree, options) {                                         // 52\n    if (isObject(tree)) {                                                   // 53\n      fileMergeContents(root, tree, options);                               // 54\n      if (isFunction(onInstall)) {                                          // 55\n        onInstall(rootRequire);                                             // 56\n      }                                                                     // 57\n    }                                                                       // 58\n    return rootRequire;                                                     // 59\n  }                                                                         // 60\n                                                                            // 61\n  function getOwn(obj, key) {                                               // 62\n    return hasOwn.call(obj, key) && obj[key];                               // 63\n  }                                                                         // 64\n                                                                            // 65\n  function isObject(value) {                                                // 66\n    return value && typeof value === \"object\";                              // 67\n  }                                                                         // 68\n                                                                            // 69\n  function isFunction(value) {                                              // 70\n    return typeof value === \"function\";                                     // 71\n  }                                                                         // 72\n                                                                            // 73\n  function isString(value) {                                                // 74\n    return typeof value === \"string\";                                       // 75\n  }                                                                         // 76\n                                                                            // 77\n  function makeRequire(file) {                                              // 78\n    function require(id) {                                                  // 79\n      var result = fileResolve(file, id);                                   // 80\n      if (result) {                                                         // 81\n        return fileEvaluate(result);                                        // 82\n      }                                                                     // 83\n                                                                            // 84\n      var error = new Error(\"Cannot find module '\" + id + \"'\");             // 85\n                                                                            // 86\n      if (isFunction(fallback)) {                                           // 87\n        return fallback(                                                    // 88\n          id, // The missing module identifier.                             // 89\n          file.m.id, // The path of the requiring file.                     // 90\n          error // The error we would have thrown.                          // 91\n        );                                                                  // 92\n      }                                                                     // 93\n                                                                            // 94\n      throw error;                                                          // 95\n    }                                                                       // 96\n                                                                            // 97\n    require.resolve = function (id) {                                       // 98\n      var f = fileResolve(file, id);                                        // 99\n      if (f) return f.m.id;                                                 // 100\n      throw new Error(\"Cannot find module '\" + id + \"'\");                   // 101\n    };                                                                      // 102\n                                                                            // 103\n    // A function that immediately returns true iff all the transitive      // 104\n    // dependencies of the module identified by id have been installed.     // 105\n    // This function can be used with options.onInstall to implement        // 106\n    // asynchronous module loading APIs like require.ensure.                // 107\n    require.ready = function (id) {                                         // 108\n      return fileReady(fileResolve(file, id));                              // 109\n    };                                                                      // 110\n                                                                            // 111\n    if (requireMethods) {                                                   // 112\n      Object.keys(requireMethods).forEach(function (name) {                 // 113\n        if (isFunction(requireMethods[name])) {                             // 114\n          require[name] = requireMethods[name].bind(require);               // 115\n        }                                                                   // 116\n      });                                                                   // 117\n    }                                                                       // 118\n                                                                            // 119\n    return require;                                                         // 120\n  }                                                                         // 121\n                                                                            // 122\n  // File objects represent either directories or modules that have been    // 123\n  // installed. When a `File` respresents a directory, its `.c` (contents)  // 124\n  // property is an object containing the names of the files (or            // 125\n  // directories) that it contains. When a `File` represents a module, its  // 126\n  // `.c` property is a function that can be invoked with the appropriate   // 127\n  // `(require, exports, module)` arguments to evaluate the module. If the  // 128\n  // `.c` property is a string, that string will be resolved as a module    // 129\n  // identifier, and the exports of the resulting module will provide the   // 130\n  // exports of the original file. The `.p` (parent) property of a File is  // 131\n  // either a directory `File` or `null`. Note that a child may claim       // 132\n  // another `File` as its parent even if the parent does not have an       // 133\n  // entry for that child in its `.c` object.  This is important for        // 134\n  // implementing anonymous files, and preventing child modules from using  // 135\n  // `../relative/identifier` syntax to examine unrelated modules.          // 136\n  function File(name, parent) {                                             // 137\n    var file = this;                                                        // 138\n                                                                            // 139\n    // Link to the parent file.                                             // 140\n    file.p = parent = parent || null;                                       // 141\n                                                                            // 142\n    // The module object for this File, which will eventually boast an      // 143\n    // .exports property when/if the file is evaluated.                     // 144\n    file.m = new Module(name, parent && parent.m);                          // 145\n  }                                                                         // 146\n                                                                            // 147\n  // A file is ready if all of its dependencies are installed and ready.    // 148\n  function fileReady(file) {                                                // 149\n    return file && (                                                        // 150\n      file.ready || ( // Return true immediately if already ready.          // 151\n        file.ready = true, // Short-circuit circular fileReady calls.       // 152\n        file.ready = // Now compute the actual value of file.ready.         // 153\n          // The current file is aliased (or symbolically linked) to the    // 154\n          // file obtained by resolving the `file.c` string as a module     // 155\n          // identifier, so regard it as ready iff the resolved file exists\n          // and is ready.                                                  // 157\n          isString(file.c) ? fileReady(fileResolve(file, file.c)) :         // 158\n          // Here file.c is a module factory function with an array of      // 159\n          // dependencies `.d` that must be ready before the current file   // 160\n          // can be considered ready.                                       // 161\n          isFunction(file.c) && file.c.d.every(function (dep, i) {          // 162\n            if (fileReady(fileResolve(file, dep))) {                        // 163\n              delete file.c.d[i]; // Ignore this dependency once ready.     // 164\n              return true;                                                  // 165\n            }                                                               // 166\n          })                                                                // 167\n      )                                                                     // 168\n    );                                                                      // 169\n  }                                                                         // 170\n                                                                            // 171\n  function fileEvaluate(file) {                                             // 172\n    var contents = file && file.c;                                          // 173\n    var module = file.m;                                                    // 174\n    if (! hasOwn.call(module, \"exports\")) {                                 // 175\n      contents(                                                             // 176\n        file.r = file.r || makeRequire(file),                               // 177\n        module.exports = {},                                                // 178\n        module,                                                             // 179\n        file.m.id,                                                          // 180\n        file.p.m.id                                                         // 181\n      );                                                                    // 182\n    }                                                                       // 183\n    return module.exports;                                                  // 184\n  }                                                                         // 185\n                                                                            // 186\n  function fileIsDirectory(file) {                                          // 187\n    return file && isObject(file.c);                                        // 188\n  }                                                                         // 189\n                                                                            // 190\n  function fileMergeContents(file, contents, options) {                     // 191\n    // If contents is an array of strings and functions, return the last    // 192\n    // function with a `.d` property containing all the strings.            // 193\n    if (Array.isArray(contents)) {                                          // 194\n      var deps = [];                                                        // 195\n                                                                            // 196\n      contents.forEach(function (item) {                                    // 197\n        if (isString(item)) {                                               // 198\n          deps.push(item);                                                  // 199\n        } else if (isFunction(item)) {                                      // 200\n          contents = item;                                                  // 201\n        }                                                                   // 202\n      });                                                                   // 203\n                                                                            // 204\n      if (isFunction(contents)) {                                           // 205\n        contents.d = deps;                                                  // 206\n      } else {                                                              // 207\n        // If the array did not contain a function, merge nothing.          // 208\n        contents = null;                                                    // 209\n      }                                                                     // 210\n                                                                            // 211\n    } else if (isFunction(contents)) {                                      // 212\n      // If contents is already a function, make sure it has `.d`.          // 213\n      contents.d = contents.d || [];                                        // 214\n                                                                            // 215\n    } else if (! isString(contents) &&                                      // 216\n               ! isObject(contents)) {                                      // 217\n      // If contents is neither an array nor a function nor a string nor    // 218\n      // an object, just give up and merge nothing.                         // 219\n      contents = null;                                                      // 220\n    }                                                                       // 221\n                                                                            // 222\n    if (contents) {                                                         // 223\n      file.c = file.c || (isObject(contents) ? {} : contents);              // 224\n      if (isObject(contents) && fileIsDirectory(file)) {                    // 225\n        Object.keys(contents).forEach(function (key) {                      // 226\n          if (key === \"..\") {                                               // 227\n            child = file.p;                                                 // 228\n                                                                            // 229\n          } else {                                                          // 230\n            var child = getOwn(file.c, key);                                // 231\n            if (! child) {                                                  // 232\n              child = file.c[key] = new File(                               // 233\n                file.m.id.replace(/\\/*$/, \"/\") + key,                       // 234\n                file                                                        // 235\n              );                                                            // 236\n                                                                            // 237\n              child.o = options;                                            // 238\n            }                                                               // 239\n          }                                                                 // 240\n                                                                            // 241\n          fileMergeContents(child, contents[key], options);                 // 242\n        });                                                                 // 243\n      }                                                                     // 244\n    }                                                                       // 245\n  }                                                                         // 246\n                                                                            // 247\n  function fileAppendIdPart(file, part, extensions) {                       // 248\n    // Always append relative to a directory.                               // 249\n    while (file && ! fileIsDirectory(file)) {                               // 250\n      file = file.p;                                                        // 251\n    }                                                                       // 252\n                                                                            // 253\n    if (! file || ! part || part === \".\") {                                 // 254\n      return file;                                                          // 255\n    }                                                                       // 256\n                                                                            // 257\n    if (part === \"..\") {                                                    // 258\n      return file.p;                                                        // 259\n    }                                                                       // 260\n                                                                            // 261\n    var exactChild = getOwn(file.c, part);                                  // 262\n                                                                            // 263\n    // Only consider multiple file extensions if this part is the last      // 264\n    // part of a module identifier and not equal to `.` or `..`, and there  // 265\n    // was no exact match or the exact match was a directory.               // 266\n    if (extensions && (! exactChild || fileIsDirectory(exactChild))) {      // 267\n      for (var e = 0; e < extensions.length; ++e) {                         // 268\n        var child = getOwn(file.c, part + extensions[e]);                   // 269\n        if (child) {                                                        // 270\n          return child;                                                     // 271\n        }                                                                   // 272\n      }                                                                     // 273\n    }                                                                       // 274\n                                                                            // 275\n    return exactChild;                                                      // 276\n  }                                                                         // 277\n                                                                            // 278\n  function fileAppendId(file, id) {                                         // 279\n    var parts = id.split(\"/\");                                              // 280\n    var exts = file.o && file.o.extensions || extensions;                   // 281\n                                                                            // 282\n    // Use `Array.prototype.every` to terminate iteration early if          // 283\n    // `fileAppendIdPart` returns a falsy value.                            // 284\n    parts.every(function (part, i) {                                        // 285\n      return file = i < parts.length - 1                                    // 286\n        ? fileAppendIdPart(file, part)                                      // 287\n        : fileAppendIdPart(file, part, exts);                               // 288\n    });                                                                     // 289\n                                                                            // 290\n    return file;                                                            // 291\n  }                                                                         // 292\n                                                                            // 293\n  function fileResolve(file, id, seenDirFiles) {                            // 294\n    file =                                                                  // 295\n      // Absolute module identifiers (i.e. those that begin with a `/`      // 296\n      // character) are interpreted relative to the root directory, which   // 297\n      // is a slight deviation from Node, which has access to the entire    // 298\n      // file system.                                                       // 299\n      id.charAt(0) === \"/\" ? fileAppendId(root, id) :                       // 300\n      // Relative module identifiers are interpreted relative to the        // 301\n      // current file, naturally.                                           // 302\n      id.charAt(0) === \".\" ? fileAppendId(file, id) :                       // 303\n      // Top-level module identifiers are interpreted as referring to       // 304\n      // packages in `node_modules` directories.                            // 305\n      nodeModulesLookup(file, id);                                          // 306\n                                                                            // 307\n    // If the identifier resolves to a directory, we use the same logic as  // 308\n    // Node to find an `index.js` or `package.json` file to evaluate.       // 309\n    while (fileIsDirectory(file)) {                                         // 310\n      seenDirFiles = seenDirFiles || [];                                    // 311\n                                                                            // 312\n      // If the \"main\" field of a `package.json` file resolves to a         // 313\n      // directory we've already considered, then we should not attempt to  // 314\n      // read the same `package.json` file again. Using an array as a set   // 315\n      // is acceptable here because the number of directories to consider   // 316\n      // is rarely greater than 1 or 2. Also, using indexOf allows us to    // 317\n      // store File objects instead of strings.                             // 318\n      if (seenDirFiles.indexOf(file) < 0) {                                 // 319\n        seenDirFiles.push(file);                                            // 320\n                                                                            // 321\n        var pkgJsonFile = fileAppendIdPart(file, \"package.json\");           // 322\n        var main = pkgJsonFile && fileEvaluate(pkgJsonFile).main;           // 323\n        if (isString(main)) {                                               // 324\n          // The \"main\" field of package.json does not have to begin with   // 325\n          // ./ to be considered relative, so first we try simply           // 326\n          // appending it to the directory path before falling back to a    // 327\n          // full fileResolve, which might return a package from a          // 328\n          // node_modules directory.                                        // 329\n          file = fileAppendId(file, main) ||                                // 330\n            fileResolve(file, main, seenDirFiles);                          // 331\n                                                                            // 332\n          if (file) {                                                       // 333\n            // The fileAppendId call above may have returned a directory,   // 334\n            // so continue the loop to make sure we resolve it to a         // 335\n            // non-directory file.                                          // 336\n            continue;                                                       // 337\n          }                                                                 // 338\n        }                                                                   // 339\n      }                                                                     // 340\n                                                                            // 341\n      // If we didn't find a `package.json` file, or it didn't have a       // 342\n      // resolvable `.main` property, the only possibility left to          // 343\n      // consider is that this directory contains an `index.js` module.     // 344\n      // This assignment almost always terminates the while loop, because   // 345\n      // there's very little chance `fileIsDirectory(file)` will be true    // 346\n      // for the result of `fileAppendIdPart(file, \"index.js\")`. However,   // 347\n      // in principle it is remotely possible that a file called            // 348\n      // `index.js` could be a directory instead of a file.                 // 349\n      file = fileAppendIdPart(file, \"index.js\");                            // 350\n    }                                                                       // 351\n                                                                            // 352\n    if (file && isString(file.c)) {                                         // 353\n      file = fileResolve(file, file.c, seenDirFiles);                       // 354\n    }                                                                       // 355\n                                                                            // 356\n    return file;                                                            // 357\n  };                                                                        // 358\n                                                                            // 359\n  function nodeModulesLookup(file, id) {                                    // 360\n    if (isFunction(override)) {                                             // 361\n      id = override(id, file.m.id);                                         // 362\n    }                                                                       // 363\n                                                                            // 364\n    if (isString(id)) {                                                     // 365\n      for (var resolved; file && ! resolved; file = file.p) {               // 366\n        resolved = fileIsDirectory(file) &&                                 // 367\n          fileAppendId(file, \"node_modules/\" + id);                         // 368\n      }                                                                     // 369\n                                                                            // 370\n      return resolved;                                                      // 371\n    }                                                                       // 372\n  }                                                                         // 373\n                                                                            // 374\n  return install;                                                           // 375\n};                                                                          // 376\n                                                                            // 377\nif (typeof exports === \"object\") {                                          // 378\n  exports.makeInstaller = makeInstaller;                                    // 379\n}                                                                           // 380\n                                                                            // 381\n//////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n// packages/modules-runtime/modules-runtime.js                              //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n                                                                            //\nvar options = {                                                             // 1\n  // File extensions to try when an imported module identifier does not     // 2\n  // exactly match any installed file.                                      // 3\n  extensions: []                                                            // 4\n};                                                                          // 5\n                                                                            // 6\nvar hasOwn = options.hasOwnProperty;                                        // 7\n                                                                            // 8\n// RegExp matching strings that don't start with a `.` or a `/`.            // 9\nvar topLevelIdPattern = /^[^./]/;                                           // 10\n                                                                            // 11\n// This function will be called whenever a module identifier that hasn't    // 12\n// been installed is required. For backwards compatibility, and so that we  // 13\n// can require binary dependencies on the server, we implement the          // 14\n// fallback in terms of Npm.require.                                        // 15\noptions.fallback = function (id, dir, error) {                              // 16\n  // For simplicity, we honor only top-level module identifiers here.       // 17\n  // We could try to honor relative and absolute module identifiers by      // 18\n  // somehow combining `id` with `dir`, but we'd have to be really careful  // 19\n  // that the resulting modules were located in a known directory (not      // 20\n  // some arbitrary location on the file system), and we only really need   // 21\n  // the fallback for dependencies installed in node_modules directories.   // 22\n  if (topLevelIdPattern.test(id)) {                                         // 23\n    var parts = id.split(\"/\");                                              // 24\n    if (parts.length === 2 &&                                               // 25\n        parts[0] === \"meteor\" &&                                            // 26\n        hasOwn.call(Package, parts[1])) {                                   // 27\n      return Package[parts[1]];                                             // 28\n    }                                                                       // 29\n                                                                            // 30\n    if (typeof Npm === \"object\" &&                                          // 31\n        typeof Npm.require === \"function\") {                                // 32\n      return Npm.require(id);                                               // 33\n    }                                                                       // 34\n  }                                                                         // 35\n                                                                            // 36\n  throw error;                                                              // 37\n};                                                                          // 38\n                                                                            // 39\nvar install = makeInstaller(options);                                       // 40\n                                                                            // 41\n(install.addExtension = function (ext) {                                    // 42\n  var args = arguments;                                                     // 43\n  for (var i = 0; i < args.length; ++i) {                                   // 44\n    ext = args[i].toLowerCase();                                            // 45\n                                                                            // 46\n    if (! /^\\.\\w+/.test(ext)) {                                             // 47\n      throw new Error(\"bad module extension: \" + ext);                      // 48\n    }                                                                       // 49\n                                                                            // 50\n    var extensions = options.extensions;                                    // 51\n    if (extensions.indexOf(ext) < 0) {                                      // 52\n      extensions.push(ext);                                                 // 53\n    }                                                                       // 54\n  }                                                                         // 55\n})(\".js\", \".json\");                                                         // 56\n                                                                            // 57\nmeteorInstall = install;                                                    // 58\n                                                                            // 59\n//////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['modules-runtime'] = {}, {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules-runtime.js","sourceMap":{"version":3,"sources":["/packages/modules-runtime/.npm/package/node_modules/install/install.js","/packages/modules-runtime/modules-runtime.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kF;;;;;;;;;;;;;;;;;AC5XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iF","file":"/packages/modules-runtime.js","sourcesContent":["makeInstaller = function (options) {\n  options = options || {};\n\n  // These file extensions will be appended to required module identifiers\n  // if they do not exactly match an installed module.\n  var extensions = options.extensions || [\".js\", \".json\"];\n\n  // This constructor will be used to instantiate the module objects\n  // passed to module factory functions (i.e. the third argument after\n  // require and exports).\n  var Module = options.Module || function Module(id, parent) {\n    this.id = id;\n    this.parent = parent;\n  };\n\n  // If defined, the options.onInstall function will be called any time\n  // new modules are installed.\n  var onInstall = options.onInstall;\n\n  // If defined, the options.override function will be called before\n  // looking up any top-level package identifiers in node_modules\n  // directories. It can either return a string to provide an alternate\n  // package identifier, or a non-string value to prevent the lookup from\n  // proceeding.\n  var override = options.override;\n\n  // If defined, the options.fallback function will be called when no\n  // installed module is found for a required module identifier. Often\n  // options.fallback will be implemented in terms of the native Node\n  // require function, which has the ability to load binary modules.\n  var fallback = options.fallback;\n\n  // Whenever a new require function is created in the makeRequire\n  // function below, any methods contained by options.requireMethods will\n  // be bound and attached as methods to that function object. This option\n  // is intended to support user-defined require.* extensions like\n  // require.ensure and require.promise.\n  var requireMethods = options.requireMethods;\n\n  // Nothing special about MISSING.hasOwnProperty, except that it's fewer\n  // characters than Object.prototype.hasOwnProperty after minification.\n  var hasOwn = {}.hasOwnProperty;\n\n  // The file object representing the root directory of the installed\n  // module tree.\n  var root = new File(\"/\", new File(\"/..\"));\n  var rootRequire = makeRequire(root);\n\n  // Merges the given tree of directories and module factory functions\n  // into the tree of installed modules and returns a require function\n  // that behaves as if called from a module in the root directory.\n  function install(tree, options) {\n    if (isObject(tree)) {\n      fileMergeContents(root, tree, options);\n      if (isFunction(onInstall)) {\n        onInstall(rootRequire);\n      }\n    }\n    return rootRequire;\n  }\n\n  function getOwn(obj, key) {\n    return hasOwn.call(obj, key) && obj[key];\n  }\n\n  function isObject(value) {\n    return value && typeof value === \"object\";\n  }\n\n  function isFunction(value) {\n    return typeof value === \"function\";\n  }\n\n  function isString(value) {\n    return typeof value === \"string\";\n  }\n\n  function makeRequire(file) {\n    function require(id) {\n      var result = fileResolve(file, id);\n      if (result) {\n        return fileEvaluate(result);\n      }\n\n      var error = new Error(\"Cannot find module '\" + id + \"'\");\n\n      if (isFunction(fallback)) {\n        return fallback(\n          id, // The missing module identifier.\n          file.m.id, // The path of the requiring file.\n          error // The error we would have thrown.\n        );\n      }\n\n      throw error;\n    }\n\n    require.resolve = function (id) {\n      var f = fileResolve(file, id);\n      if (f) return f.m.id;\n      throw new Error(\"Cannot find module '\" + id + \"'\");\n    };\n\n    // A function that immediately returns true iff all the transitive\n    // dependencies of the module identified by id have been installed.\n    // This function can be used with options.onInstall to implement\n    // asynchronous module loading APIs like require.ensure.\n    require.ready = function (id) {\n      return fileReady(fileResolve(file, id));\n    };\n\n    if (requireMethods) {\n      Object.keys(requireMethods).forEach(function (name) {\n        if (isFunction(requireMethods[name])) {\n          require[name] = requireMethods[name].bind(require);\n        }\n      });\n    }\n\n    return require;\n  }\n\n  // File objects represent either directories or modules that have been\n  // installed. When a `File` respresents a directory, its `.c` (contents)\n  // property is an object containing the names of the files (or\n  // directories) that it contains. When a `File` represents a module, its\n  // `.c` property is a function that can be invoked with the appropriate\n  // `(require, exports, module)` arguments to evaluate the module. If the\n  // `.c` property is a string, that string will be resolved as a module\n  // identifier, and the exports of the resulting module will provide the\n  // exports of the original file. The `.p` (parent) property of a File is\n  // either a directory `File` or `null`. Note that a child may claim\n  // another `File` as its parent even if the parent does not have an\n  // entry for that child in its `.c` object.  This is important for\n  // implementing anonymous files, and preventing child modules from using\n  // `../relative/identifier` syntax to examine unrelated modules.\n  function File(name, parent) {\n    var file = this;\n\n    // Link to the parent file.\n    file.p = parent = parent || null;\n\n    // The module object for this File, which will eventually boast an\n    // .exports property when/if the file is evaluated.\n    file.m = new Module(name, parent && parent.m);\n  }\n\n  // A file is ready if all of its dependencies are installed and ready.\n  function fileReady(file) {\n    return file && (\n      file.ready || ( // Return true immediately if already ready.\n        file.ready = true, // Short-circuit circular fileReady calls.\n        file.ready = // Now compute the actual value of file.ready.\n          // The current file is aliased (or symbolically linked) to the\n          // file obtained by resolving the `file.c` string as a module\n          // identifier, so regard it as ready iff the resolved file exists\n          // and is ready.\n          isString(file.c) ? fileReady(fileResolve(file, file.c)) :\n          // Here file.c is a module factory function with an array of\n          // dependencies `.d` that must be ready before the current file\n          // can be considered ready.\n          isFunction(file.c) && file.c.d.every(function (dep, i) {\n            if (fileReady(fileResolve(file, dep))) {\n              delete file.c.d[i]; // Ignore this dependency once ready.\n              return true;\n            }\n          })\n      )\n    );\n  }\n\n  function fileEvaluate(file) {\n    var contents = file && file.c;\n    var module = file.m;\n    if (! hasOwn.call(module, \"exports\")) {\n      contents(\n        file.r = file.r || makeRequire(file),\n        module.exports = {},\n        module,\n        file.m.id,\n        file.p.m.id\n      );\n    }\n    return module.exports;\n  }\n\n  function fileIsDirectory(file) {\n    return file && isObject(file.c);\n  }\n\n  function fileMergeContents(file, contents, options) {\n    // If contents is an array of strings and functions, return the last\n    // function with a `.d` property containing all the strings.\n    if (Array.isArray(contents)) {\n      var deps = [];\n\n      contents.forEach(function (item) {\n        if (isString(item)) {\n          deps.push(item);\n        } else if (isFunction(item)) {\n          contents = item;\n        }\n      });\n\n      if (isFunction(contents)) {\n        contents.d = deps;\n      } else {\n        // If the array did not contain a function, merge nothing.\n        contents = null;\n      }\n\n    } else if (isFunction(contents)) {\n      // If contents is already a function, make sure it has `.d`.\n      contents.d = contents.d || [];\n\n    } else if (! isString(contents) &&\n               ! isObject(contents)) {\n      // If contents is neither an array nor a function nor a string nor\n      // an object, just give up and merge nothing.\n      contents = null;\n    }\n\n    if (contents) {\n      file.c = file.c || (isObject(contents) ? {} : contents);\n      if (isObject(contents) && fileIsDirectory(file)) {\n        Object.keys(contents).forEach(function (key) {\n          if (key === \"..\") {\n            child = file.p;\n\n          } else {\n            var child = getOwn(file.c, key);\n            if (! child) {\n              child = file.c[key] = new File(\n                file.m.id.replace(/\\/*$/, \"/\") + key,\n                file\n              );\n\n              child.o = options;\n            }\n          }\n\n          fileMergeContents(child, contents[key], options);\n        });\n      }\n    }\n  }\n\n  function fileAppendIdPart(file, part, extensions) {\n    // Always append relative to a directory.\n    while (file && ! fileIsDirectory(file)) {\n      file = file.p;\n    }\n\n    if (! file || ! part || part === \".\") {\n      return file;\n    }\n\n    if (part === \"..\") {\n      return file.p;\n    }\n\n    var exactChild = getOwn(file.c, part);\n\n    // Only consider multiple file extensions if this part is the last\n    // part of a module identifier and not equal to `.` or `..`, and there\n    // was no exact match or the exact match was a directory.\n    if (extensions && (! exactChild || fileIsDirectory(exactChild))) {\n      for (var e = 0; e < extensions.length; ++e) {\n        var child = getOwn(file.c, part + extensions[e]);\n        if (child) {\n          return child;\n        }\n      }\n    }\n\n    return exactChild;\n  }\n\n  function fileAppendId(file, id) {\n    var parts = id.split(\"/\");\n    var exts = file.o && file.o.extensions || extensions;\n\n    // Use `Array.prototype.every` to terminate iteration early if\n    // `fileAppendIdPart` returns a falsy value.\n    parts.every(function (part, i) {\n      return file = i < parts.length - 1\n        ? fileAppendIdPart(file, part)\n        : fileAppendIdPart(file, part, exts);\n    });\n\n    return file;\n  }\n\n  function fileResolve(file, id, seenDirFiles) {\n    file =\n      // Absolute module identifiers (i.e. those that begin with a `/`\n      // character) are interpreted relative to the root directory, which\n      // is a slight deviation from Node, which has access to the entire\n      // file system.\n      id.charAt(0) === \"/\" ? fileAppendId(root, id) :\n      // Relative module identifiers are interpreted relative to the\n      // current file, naturally.\n      id.charAt(0) === \".\" ? fileAppendId(file, id) :\n      // Top-level module identifiers are interpreted as referring to\n      // packages in `node_modules` directories.\n      nodeModulesLookup(file, id);\n\n    // If the identifier resolves to a directory, we use the same logic as\n    // Node to find an `index.js` or `package.json` file to evaluate.\n    while (fileIsDirectory(file)) {\n      seenDirFiles = seenDirFiles || [];\n\n      // If the \"main\" field of a `package.json` file resolves to a\n      // directory we've already considered, then we should not attempt to\n      // read the same `package.json` file again. Using an array as a set\n      // is acceptable here because the number of directories to consider\n      // is rarely greater than 1 or 2. Also, using indexOf allows us to\n      // store File objects instead of strings.\n      if (seenDirFiles.indexOf(file) < 0) {\n        seenDirFiles.push(file);\n\n        var pkgJsonFile = fileAppendIdPart(file, \"package.json\");\n        var main = pkgJsonFile && fileEvaluate(pkgJsonFile).main;\n        if (isString(main)) {\n          // The \"main\" field of package.json does not have to begin with\n          // ./ to be considered relative, so first we try simply\n          // appending it to the directory path before falling back to a\n          // full fileResolve, which might return a package from a\n          // node_modules directory.\n          file = fileAppendId(file, main) ||\n            fileResolve(file, main, seenDirFiles);\n\n          if (file) {\n            // The fileAppendId call above may have returned a directory,\n            // so continue the loop to make sure we resolve it to a\n            // non-directory file.\n            continue;\n          }\n        }\n      }\n\n      // If we didn't find a `package.json` file, or it didn't have a\n      // resolvable `.main` property, the only possibility left to\n      // consider is that this directory contains an `index.js` module.\n      // This assignment almost always terminates the while loop, because\n      // there's very little chance `fileIsDirectory(file)` will be true\n      // for the result of `fileAppendIdPart(file, \"index.js\")`. However,\n      // in principle it is remotely possible that a file called\n      // `index.js` could be a directory instead of a file.\n      file = fileAppendIdPart(file, \"index.js\");\n    }\n\n    if (file && isString(file.c)) {\n      file = fileResolve(file, file.c, seenDirFiles);\n    }\n\n    return file;\n  };\n\n  function nodeModulesLookup(file, id) {\n    if (isFunction(override)) {\n      id = override(id, file.m.id);\n    }\n\n    if (isString(id)) {\n      for (var resolved; file && ! resolved; file = file.p) {\n        resolved = fileIsDirectory(file) &&\n          fileAppendId(file, \"node_modules/\" + id);\n      }\n\n      return resolved;\n    }\n  }\n\n  return install;\n};\n\nif (typeof exports === \"object\") {\n  exports.makeInstaller = makeInstaller;\n}\n","var options = {\n  // File extensions to try when an imported module identifier does not\n  // exactly match any installed file.\n  extensions: []\n};\n\nvar hasOwn = options.hasOwnProperty;\n\n// RegExp matching strings that don't start with a `.` or a `/`.\nvar topLevelIdPattern = /^[^./]/;\n\n// This function will be called whenever a module identifier that hasn't\n// been installed is required. For backwards compatibility, and so that we\n// can require binary dependencies on the server, we implement the\n// fallback in terms of Npm.require.\noptions.fallback = function (id, dir, error) {\n  // For simplicity, we honor only top-level module identifiers here.\n  // We could try to honor relative and absolute module identifiers by\n  // somehow combining `id` with `dir`, but we'd have to be really careful\n  // that the resulting modules were located in a known directory (not\n  // some arbitrary location on the file system), and we only really need\n  // the fallback for dependencies installed in node_modules directories.\n  if (topLevelIdPattern.test(id)) {\n    var parts = id.split(\"/\");\n    if (parts.length === 2 &&\n        parts[0] === \"meteor\" &&\n        hasOwn.call(Package, parts[1])) {\n      return Package[parts[1]];\n    }\n\n    if (typeof Npm === \"object\" &&\n        typeof Npm.require === \"function\") {\n      return Npm.require(id);\n    }\n  }\n\n  throw error;\n};\n\nvar install = makeInstaller(options);\n\n(install.addExtension = function (ext) {\n  var args = arguments;\n  for (var i = 0; i < args.length; ++i) {\n    ext = args[i].toLowerCase();\n\n    if (! /^\\.\\w+/.test(ext)) {\n      throw new Error(\"bad module extension: \" + ext);\n    }\n\n    var extensions = options.extensions;\n    if (extensions.indexOf(ext) < 0) {\n      extensions.push(ext);\n    }\n  }\n})(\".js\", \".json\");\n\nmeteorInstall = install;\n"]}}]